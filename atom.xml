<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://250786898.github.io</id>
    <title>彭美泉个人博客</title>
    <updated>2020-03-25T10:13:38.705Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://250786898.github.io"/>
    <link rel="self" href="https://250786898.github.io/atom.xml"/>
    <subtitle>程序员也可以有艺术的人生</subtitle>
    <logo>https://250786898.github.io/images/avatar.png</logo>
    <icon>https://250786898.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 彭美泉个人博客</rights>
    <entry>
        <title type="html"><![CDATA[Webpack4.0学习笔记]]></title>
        <id>https://250786898.github.io/post/webpack40-xue-xi-bi-ji/</id>
        <link href="https://250786898.github.io/post/webpack40-xue-xi-bi-ji/">
        </link>
        <updated>2020-03-24T09:17:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="webpack-究竟是什么">webpack 究竟是什么？</h1>
<p><code>webpack</code> 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)，当 <code>webpack</code> 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 <code>bundle</code>。</p>
<h2 id="传统模式开发">传统模式开发</h2>
<p>新建 <code>index.html</code>，如下:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;body&gt;
  &lt;p&gt;这是网页内容&lt;/p&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  &lt;script src=&quot;./header.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./content.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./footer.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>再建立<code>index.js</code>、<code>header.js</code>、 <code>content.js</code>、 <code>footer.js</code></p>
<pre><code>//index.js
new Header()
new Content()
new Footer()

//header.js
function Header () {
  var dom = document.getElementById('root')
  var header = document.createElement('div')
  header.innerText = 'header'
  dom.append(header)
}

//content.js
function Content () {
  var dom = document.getElementById('root')
  var content = document.createElement('div')
  content.innerText = 'content'
  dom.append(content)
}

//footer.js
function Footer () {
  var dom = document.getElementById('root')
  var footer = document.createElement('div')
  footer.innerText = 'footer'
  do
m.append(footer)
}
</code></pre>
<p>这样面向对象new出各个模块的构造函数，在一定程度上比面相过程全部写在一个文件上好维护，但是<code>Header</code>、<code>Contet</code>这些构造函数指向问题还要回到<code>index.html</code>文件一一对应查找,就造成了在<code>index.js</code>上指定不明确,如果我们能像以下代码一样导入就能解决这个问题了</p>
<pre><code>//index.js
import Header from './header.js'
import Content from './content.js'
import Footer from './footer.js'

new Header()
new Content()
new Footer()
</code></pre>
<p>遗憾的是，浏览器不会识别这种es6的语法，使用浏览器访问<code>index.html</code>会发现控制台会报错。此时我们的<code>webpack</code>就可以为了解决这种问题而诞生了</p>
<h2 id="使用webpack模块化开发">使用webpack模块化开发</h2>
<p>首先想使用<code>webpack</code>,我们得先<code>npm</code>初始化包并安装webpack</p>
<pre><code>npm init
npm install webpack webpack-cli -D
</code></pre>
<p>想用<code>ESmodule</code> 语法导出，我们得修增加导出语法</p>
<pre><code>//header.js
export default Header

//content.js
export default Content

//footer.js
export default Footer
</code></pre>
<p>然后我们就可以使用<code>npx</code> 运行 <code>webpack</code> 执行 <code>index.js</code> 文件</p>
<pre><code>npx webpack index.js
</code></pre>
<p>执行后，我们发发现根目录下生成了一个 <code>dist/main.js</code>目录文件，这便是webpack默认出口输出（<code>output</code>），后面会介绍。这个文件便是webpack翻译我们的<code>index.js</code>生成后的文件，所以有的人会称<code>webpack</code>是<code>JS</code>的翻译器，但这说法也并不完成正确。既然我们翻译了文件，我们就需要在<code>index.html</code>修改成导入后的文件,如下修改：</p>
<pre><code>//index.html
&lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>修改完成后打开浏览器重新访问<code>index.html</code>发现可以生成相对于模块并且没有报错了，这就是<code>webpack</code>的模块开发。</p>
<h1 id="使用webpack的配置文件">使用webpack的配置文件</h1>
<h2 id="使用一个配置文件">使用一个配置文件</h2>
<p>在 <code>webpack v4</code> 中，可以无须任何配置，因为<code>webpack</code>提供了默认配置，然而大多数项目会需要很复杂的设置，这就是为什么 webpack 仍然要支持 配置文件。这比在 terminal(终端) 中手动输入大量命令要高效的多，所以让我们在根目录创建一个配置文件：<code>webpack.config.js</code>（默认配置文件，可通过<code>npx webpack --config webpack.config.js</code>修改）</p>
<pre><code>//webpack.config.js
const path = require('path')
module.exports = {
  entry: './src/index.jss' , //入口文件 默认：src/index.js
  output: { //出口文件 默认: dist/main.js
    filename: 'bundle.js', //输出的文件名 
    path: path.resolve(__dirname,'dist') //输出的路径，只能是绝对路径
  }
}
</code></pre>
<p>新建src文件夹，移动<code>index.js,header.js</code>等js到src文件夹，执行以下代码会发现dist文件夹生成了新的出口文件<code>bundele.js</code></p>
<pre><code>npx webpack src/index.js
</code></pre>
<h2 id="npm-scripts">npm scripts</h2>
<p>考虑到用 CLI 这种方式来运行本地的 webpack 副本并不是特别方便，我们可以设置一个快捷方式。调整 package.json 文件，添加在 <code>npm scripts</code> 中添加一个 npm 命令：</p>
<pre><code>//package.json
&quot;scripts&quot;: {
    &quot;bundle&quot; : &quot;webpack&quot;
},
</code></pre>
<p>现在，可以使用 <code>npm run build</code> 命令，来替代我们之前使用的 <code>npx</code> 命令。注意，使用 <code>npm scripts</code>，我们可以像使用 npx 那样通过模块名引用本地安装的 npm packages。这是大多数基于 <code>npm</code> 的项目遵循的标准，因为它允许所有贡献者使用同一组通用脚本（如果必要，每个 flag 都带有 --config 标志）。</p>
<p>现在运行以下命令，然后看看你的脚本别名是否正常运行：</p>
<pre><code>npm run bundle
</code></pre>
<h2 id="浅析webpack打包输出内容">浅析webpack打包输出内容</h2>
<pre><code>npm run bundle

&gt; webpack4@1.0.0 bundle E:\project\webpack4
&gt; webpack

Hash: 768c04b37ed214487576
Version: webpack 4.42.0
Time: 98ms
Built at: 2020-03-24 4:57:54 PM
    Asset      Size  Chunks             Chunk Names
bundle.js  1.29 KiB       0  [emitted]  main
Entrypoint main = bundle.js
[0] ./src/index.js + 3 modules 741 bytes {0} [built]
    | ./src/index.js 147 bytes [built]
    | ./src/header.js 202 bytes [built]
    | ./src/content.js 198 bytes [built]
    | ./src/footer.js 194 bytes [built]


WARNING in configuration
The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.
You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/
</code></pre>
<p>从<code>webpack</code>打包输出的结果我们可以看出有个警告，那是因为我们没有指定打包输出的环境（<code>'development'</code> or<code>'production'</code>），我们可以在<code>webpack.config.js</code>新增以下代码:</p>
<pre><code>module.exports = {
  mode: 'development', //默认为production
  ...
}
</code></pre>
<p>重新执行<code>npm run bundle</code> 发现不会提出警告了，并且生成的<code>bundle.js</code>的代码没有被压缩</p>
<h2 id="什么是-loader">什么是 loader</h2>
<p>webpack 可以使用 <code>loader</code> 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。如果你在默认配置下打包除js文件外出错，所以我们要借助<code>loader</code>来打包js外的文件</p>
<p>现在我们在<code>src</code>文件下存放一张<code>logo.jpg</code>的图片，然后在index.js引入后使用<code>webpack</code>打开</p>
<pre><code>//index.js
const logo = require('./logo.jpg')
</code></pre>
<p>执行<code>npm run bundle</code>打包后会抛出如下错误：</p>
<pre><code>ERROR in ./src/logo.jpg 1:0
Module parse failed: Unexpected character '�' (1:0)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
(Source code omitted for this binary file)
 @ ./src/index.js 5:13-34
</code></pre>
<p>这是因为webpack像我们上面说的一样，只能打包js文件，如果想打包除js以外的静态资源，此时我们就需要借用<a href="https://webpack.docschina.org/loaders/">loader</a>来帮助我们打包图片资源。想打包图片我们首先得先安装相关的<code>loader</code></p>
<h3 id="file-loader">file-loader</h3>
<pre><code>npm install file-loader -D
</code></pre>
<p>然后我们需要在<code>webpack.config.js</code>文件下配置相关的<code>module</code>规则：</p>
<pre><code>//webpack.config.js
...
module: {
    rules: [
      {
        test: /\.jpg$/,
        use: [
          {
            loader: 'file-loader' //使用相对应的loader
          }
        ]
      }
    ]
  }
</code></pre>
<p>控制台<code>npm run bundle</code>再次运行时，发现打包成功没有报错，并且在dist出口目录生成了相应的图片资源。那我们导入的图片资源变量会是什么呢，我们试着打印一下：</p>
<pre><code>const logo = require('./logo.jpg')
console.log('logo',logo)
</code></pre>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/17110d4ca935ba3d?w=566&amp;h=153&amp;f=png&amp;s=15502" alt="" loading="lazy"><br>
可以在浏览器中看出，我们获取到的是打包生成的文件相关信息，包括图片名字。经过这个例子，我们就明白了在<code>vue</code>的脚手架项目中可以这样引入.vue相关文件的了</p>
<pre><code>import Header from 'Header.vue'
</code></pre>
<pre><code>//webpack.config.js
rules: [
    ...
      {
        test: /\.vue$/,
        use: { //只使用一个loader可以直接用对象配置
          loader: 'vue-loader'
        }
      }
    ]
</code></pre>
<p>上面案例中,我们可以看到<code>options</code>字段,这是我们可以打包文件资源的时候定义相对应的规则,比如:</p>
<pre><code>rules: [
      {
        test: /\.jpg$/,
        use: [
          {
            loader: 'file-loader', //使用相对应的loader
            options: {
              name:'[name].[ext]', //定义打包生成的文件名字
              outputPath: 'images' //定义输出的文件目录：dist/images 下
            },
          }
        ]
      }
    ]
</code></pre>
<p>这样我们就可以自定义打包文件的名字和目录，更多的规则可以查看<a href="https://webpack.js.org/loaders/file-loader/#options">官方文档配置</a></p>
<h3 id="url-loader">url-loader</h3>
<p>我们可以用<code>url-loader</code>取代<code>file-loader</code>来实现静态文件资源打包,那为什么我们有file-loader还要用url-loader,让我看看下面的例子就知道了:</p>
<p>首先我们先<code>npm install url-loader --save-dev</code>安装<code>file-loader</code>,然后在<code>webpack.config.js</code>进行相对应的配置</p>
<pre><code>rules: [
      {
        test: /\.jpg$/,
        use: [
          {
            loader: 'url-loader', //使用相对应的loader
            options: {
              limit: 10240 //单位：字节 超过10kb 的文件生成图片,否则生成base64编码
            }
          }
        ]
      }
    ]
</code></pre>
<p>运行打包后我们可以发现,超过10kb 的文件生成图片,否则生成<code>base64编码</code>。这样做的好处是什么呢，图片生成base64编码可以大大减少我们https请求，但不是所有的图片都生成base64编码，比如图片几M的生成的话，相对应js文件大小也会增加，网页打空白的时间也相对应增加，至于哪些需要转，limit需要设置多大限制根据自己的项目来，我的项目中一般是icon图标类的会转base64编码,其他大的相对应打包生成文件。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[小程序性能优化，项目规划图]]></title>
        <id>https://250786898.github.io/post/xiao-cheng-xu-xing-neng-you-hua-xiang-mu-gui-hua-tu/</id>
        <link href="https://250786898.github.io/post/xiao-cheng-xu-xing-neng-you-hua-xiang-mu-gui-hua-tu/">
        </link>
        <updated>2020-03-18T02:52:00.000Z</updated>
        <content type="html"><![CDATA[<figure data-type="image" tabindex="1"><img src="https://250786898.github.io/post-images/1584499944018.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[前端为什么要使用枚举]]></title>
        <id>https://250786898.github.io/post/qian-duan-wei-shi-me-yao-shi-yong-mei-ju/</id>
        <link href="https://250786898.github.io/post/qian-duan-wei-shi-me-yao-shi-yong-mei-ju/">
        </link>
        <updated>2020-03-10T09:21:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-枚举的业务场景与遇到的问题">一、枚举的业务场景与遇到的问题</h2>
<p>我们在日常业务开发中，经常遇到枚举，如商品状态、页面状态、审核状态等，翻阅以往的一些业务代码，会发现很多地方都是这么写的：</p>
<pre><code>&lt;span v-if=&quot;status == 0&quot;&gt;审核中&lt;/span&gt;
&lt;span v-else-if=&quot;status == 1&quot;&gt;审核通过&lt;/span&gt;
</code></pre>
<p>以上代码其实存在以下问题：</p>
<ul>
<li>
<p>魔数化：一旦有个数值改动，就得全局替换匹配</p>
</li>
<li>
<p>差语义化：无法直观通过值推导出含义<br>
于是，进阶做法我们想的是通过引入常量，如：</p>
</li>
</ul>
<pre><code>&lt;span v-if=&quot;status == STATUS.AUDITING&quot;&gt;审核中&lt;/span&gt;
&lt;span v-else-if=&quot;status == STATUS.PASS&quot;&gt;审核通过&lt;/span&gt;
</code></pre>
<p>然而，我们其实还会遇到以下场景：</p>
<p>需要拿到枚举值获得枚举含义<br>
特别是在列表中尤其常见。我们通常的做法是：建立过滤器，建立Map，如：</p>
<pre><code>export default {
    // ...
    filters: {
        statusName: status =&gt; {
            const map = {
                [STATUS.AUDITING]: '审核中',
                [STATUS.PASS]: '审核通过'
            }
            return map[status] || ''
        }
    }
}
</code></pre>
<p>这样子虽然也挺方便，但是仍然不够完美：</p>
<p>定义隔离：枚举值和枚举含义分离，还是会带来一定维护上的问题</p>
<h2 id="二-如何改善">二、如何改善？</h2>
<p>我们期望的应该是定义能够一体化，而不是分散化。参考Java里的枚举做法，其实好很多：</p>
<pre><code>public enum AgingTypeEnum {
    ALL(0, &quot;全部&quot;),
    SPECIAL(1, &quot;特批时效&quot;),
    PLATFORM(2, &quot;平台定义&quot;);
    // ...
}
</code></pre>
<p>但是，虽然TS里也实现了<strong>enum</strong>，但其实做法还是有些不一样，还是不那么利于我们的业务场景。因为TS里的enum，也不是枚举值与含义定义一体化。对于我们的业务场景，可能下面这么做更利于我们的使用：</p>
<pre><code>const STATUS = createEnum({
    AUDITING: [0, '审核中'],
    PASS: [1, '审核通过']
})

export default {
    // ...
    created() {
        this.STATUS = STATUS
    }
}
</code></pre>
<p><span v-if="status == STATUS.AUDITING">审核中</span><br>
<span v-else-if="status == STATUS.PASS">审核通过</span></p>
<pre><code>&lt;p&gt;当前状态：{STATUS.getDescFromValue(syncData.status)}&lt;/p&gt;
&lt;p&gt;也可用通过枚举名称获取描述：{STATUS.getDesc('AUDITING')}&lt;/p&gt;
</code></pre>
<p>如此一来，具有以下好处：</p>
<ul>
<li>
<p>去魔数化：后端假如改了审核中状态为2，那么我们就只需要在开头把0改为2即可</p>
</li>
<li>
<p>语义化：通过<strong>STATUS.AUDITING</strong>我们就可以大概猜出含义</p>
</li>
<li>
<p>定义一体化：枚举值和枚举描述写在了一起，不分散</p>
</li>
<li>
<p>使用方便：无需额外的过滤器，就可以通过<strong>枚举名称/枚举值</strong>获得枚举含义<br>
三、实现<br>
实现代码如下：</p>
</li>
</ul>
<pre><code>/**
 * 枚举定义工具
 * 示例：
 * const STATUS = createEnum({
 *     AUDIT_WAIT: [1, '审核中'],
 *     AUDIT_PASS: [2, '审核通过']
 * })
 * 获取枚举值：STATUS.AUDIT_WAIT
 * 获取枚举描述：STATUS.getDesc('AUDIT_WAIT')
 * 通过枚举值获取描述：STATUS.getDescFromValue(STATUS.WAIT)
 * 
 */

interface EnumDefinition {
    [enumName: string]: [number, string]
}

export default function createEnum(definition: EnumDefinition) {
    const strToValueMap = {}
    const numToDescMap = {}
    for (const enumName of Object.keys(definition)) {
        const [value, desc]: [number, string] = definition[enumName]
        strToValueMap[enumName] = value
        numToDescMap[value] = desc
    }
    return {
        ...strToValueMap,
        getDesc(enumName: string): string {
            return definition[enumName] &amp;&amp; definition[enumName][1] || ''
        },
        getDescFromValue(value: number): string {
            return numToDescMap[value] || ''
        }
    }
}
</code></pre>
<p>非TS版：</p>
<pre><code>export default function createEnum(definition) {
    const strToValueMap = {}
    const numToDescMap = {}
    for (const enumName of Object.keys(definition)) {
        const [value, desc] = definition[enumName]
        strToValueMap[enumName] = value
        numToDescMap[value] = desc
    }
    return {
        ...strToValueMap,
        getDesc(enumName) {
            return definition[enumName] &amp;&amp; definition[enumName][1] || ''
        },
        getDescFromValue(value) {
            return numToDescMap[value] || ''
        }
    }
}
</code></pre>
]]></content>
    </entry>
</feed>