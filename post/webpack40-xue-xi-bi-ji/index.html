<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>彭美泉个人博客</title>
<meta name="description" content="程序员也可以有艺术的人生" />
<link rel="shortcut icon" href="https://250786898.github.io/favicon.ico?v=1585131101460">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.7.2/animate.min.css">

<link rel="stylesheet" href="https://250786898.github.io/styles/main.css">



  </head>
  <body>
    <div id="app" class="main px-4 flex flex-col lg:flex-row">
      <div id="sidebar" class="sidebar-wrapper lg:static lg:w-1/4">
  <div class="lg:sticky top-0">
    <div class="sidebar-content">
      <div class="flex lg:block p-4 lg:px-0 items-center fixed lg:static lg:block top-0 right-0 left-0 bg-white z-50">
        <i class="ri-menu-2-line lg:mt-4 text-2xl cursor-pointer animated fadeIn" onclick="openMenu()"></i>
        <a href="https://250786898.github.io">
          <img class="animated fadeInLeft avatar rounded-lg mx-4 lg:mt-32 lg:mx-0 mt-0 lg:w-24 lg:h-24 w-12 w-12" src="https://250786898.github.io/images/avatar.png?v=1585131101460" alt="">
        </a>
        <h1 class="animated fadeInLeft lg:text-4xl font-extrabold lg:mt-8 mt-0 text-xl" style="animation-delay: 0.2s">彭美泉个人博客</h1>
      </div>
      
        <div class="animated fadeInLeft" style="animation-delay: 0.4s">
          <p class="my-4 text-gray-600 font-light hidden lg:block">
            文章目录
          </p>
          <div class="toc-container hidden lg:block">
            <ul class="markdownIt-TOC">
<li><a href="#webpack-%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88">webpack 究竟是什么？</a>
<ul>
<li><a href="#%E4%BC%A0%E7%BB%9F%E6%A8%A1%E5%BC%8F%E5%BC%80%E5%8F%91">传统模式开发</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8webpack%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91">使用webpack模块化开发</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8webpack%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">使用webpack的配置文件</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">使用一个配置文件</a></li>
<li><a href="#npm-scripts">npm scripts</a></li>
<li><a href="#%E6%B5%85%E6%9E%90webpack%E6%89%93%E5%8C%85%E8%BE%93%E5%87%BA%E5%86%85%E5%AE%B9">浅析webpack打包输出内容</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-loader">什么是 loader</a>
<ul>
<li><a href="#file-loader">file-loader</a></li>
<li><a href="#url-loader">url-loader</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      
    </div>
  </div>
</div>

<div class="menu-container">
  <i class="ri-arrow-left-line text-2xl cursor-pointer animated fadeIn close-menu-btn" onclick="closeMenu()"></i>
  <div>
    
      
        <a href="/" class="menu" style="animation-delay: 0s">
          首页
        </a>
      
    
      
        <a href="https://250786898.github.io/tags" class="menu" style="animation-delay: 0.2s" target="_blank">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu" style="animation-delay: 0.4s">
          关于
        </a>
      
    
      
        <a href="hot" class="menu" style="animation-delay: 0.6000000000000001s">
          每日看点
        </a>
      
    
  </div>
  <div class="site-footer">
    <div class="py-4 text-gray-700">Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a></div>
    <a class="rss" href="https://250786898.github.io/atom.xml" target="_blank">RSS</a>
  </div>
</div>
<div class="mask" onclick="closeMenu()">
</div>
      <div class="content-wrapper py-32 lg:p-8 lg:w-3/4 post-detail animated fadeIn">
        <h1 class="text-3xl font-bold lg:mt-16">Webpack4.0学习笔记</h1>
        <div class="text-sm text-gray-700 lg:my-8">
          2020-03-24 / 10 min read
        </div>
        
        <div class="post-content yue">
          <h1 id="webpack-究竟是什么">webpack 究竟是什么？</h1>
<p><code>webpack</code> 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)，当 <code>webpack</code> 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 <code>bundle</code>。</p>
<h2 id="传统模式开发">传统模式开发</h2>
<p>新建 <code>index.html</code>，如下:</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;body&gt;
  &lt;p&gt;这是网页内容&lt;/p&gt;
  &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
  &lt;script src=&quot;./header.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./content.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./footer.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;./index.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>再建立<code>index.js</code>、<code>header.js</code>、 <code>content.js</code>、 <code>footer.js</code></p>
<pre><code>//index.js
new Header()
new Content()
new Footer()

//header.js
function Header () {
  var dom = document.getElementById('root')
  var header = document.createElement('div')
  header.innerText = 'header'
  dom.append(header)
}

//content.js
function Content () {
  var dom = document.getElementById('root')
  var content = document.createElement('div')
  content.innerText = 'content'
  dom.append(content)
}

//footer.js
function Footer () {
  var dom = document.getElementById('root')
  var footer = document.createElement('div')
  footer.innerText = 'footer'
  do
m.append(footer)
}
</code></pre>
<p>这样面向对象new出各个模块的构造函数，在一定程度上比面相过程全部写在一个文件上好维护，但是<code>Header</code>、<code>Contet</code>这些构造函数指向问题还要回到<code>index.html</code>文件一一对应查找,就造成了在<code>index.js</code>上指定不明确,如果我们能像以下代码一样导入就能解决这个问题了</p>
<pre><code>//index.js
import Header from './header.js'
import Content from './content.js'
import Footer from './footer.js'

new Header()
new Content()
new Footer()
</code></pre>
<p>遗憾的是，浏览器不会识别这种es6的语法，使用浏览器访问<code>index.html</code>会发现控制台会报错。此时我们的<code>webpack</code>就可以为了解决这种问题而诞生了</p>
<h2 id="使用webpack模块化开发">使用webpack模块化开发</h2>
<p>首先想使用<code>webpack</code>,我们得先<code>npm</code>初始化包并安装webpack</p>
<pre><code>npm init
npm install webpack webpack-cli -D
</code></pre>
<p>想用<code>ESmodule</code> 语法导出，我们得修增加导出语法</p>
<pre><code>//header.js
export default Header

//content.js
export default Content

//footer.js
export default Footer
</code></pre>
<p>然后我们就可以使用<code>npx</code> 运行 <code>webpack</code> 执行 <code>index.js</code> 文件</p>
<pre><code>npx webpack index.js
</code></pre>
<p>执行后，我们发发现根目录下生成了一个 <code>dist/main.js</code>目录文件，这便是webpack默认出口输出（<code>output</code>），后面会介绍。这个文件便是webpack翻译我们的<code>index.js</code>生成后的文件，所以有的人会称<code>webpack</code>是<code>JS</code>的翻译器，但这说法也并不完成正确。既然我们翻译了文件，我们就需要在<code>index.html</code>修改成导入后的文件,如下修改：</p>
<pre><code>//index.html
&lt;script src=&quot;./dist/main.js&quot;&gt;&lt;/script&gt;
</code></pre>
<p>修改完成后打开浏览器重新访问<code>index.html</code>发现可以生成相对于模块并且没有报错了，这就是<code>webpack</code>的模块开发。</p>
<h1 id="使用webpack的配置文件">使用webpack的配置文件</h1>
<h2 id="使用一个配置文件">使用一个配置文件</h2>
<p>在 <code>webpack v4</code> 中，可以无须任何配置，因为<code>webpack</code>提供了默认配置，然而大多数项目会需要很复杂的设置，这就是为什么 webpack 仍然要支持 配置文件。这比在 terminal(终端) 中手动输入大量命令要高效的多，所以让我们在根目录创建一个配置文件：<code>webpack.config.js</code>（默认配置文件，可通过<code>npx webpack --config webpack.config.js</code>修改）</p>
<pre><code>//webpack.config.js
const path = require('path')
module.exports = {
  entry: './src/index.jss' , //入口文件 默认：src/index.js
  output: { //出口文件 默认: dist/main.js
    filename: 'bundle.js', //输出的文件名 
    path: path.resolve(__dirname,'dist') //输出的路径，只能是绝对路径
  }
}
</code></pre>
<p>新建src文件夹，移动<code>index.js,header.js</code>等js到src文件夹，执行以下代码会发现dist文件夹生成了新的出口文件<code>bundele.js</code></p>
<pre><code>npx webpack src/index.js
</code></pre>
<h2 id="npm-scripts">npm scripts</h2>
<p>考虑到用 CLI 这种方式来运行本地的 webpack 副本并不是特别方便，我们可以设置一个快捷方式。调整 package.json 文件，添加在 <code>npm scripts</code> 中添加一个 npm 命令：</p>
<pre><code>//package.json
&quot;scripts&quot;: {
    &quot;bundle&quot; : &quot;webpack&quot;
},
</code></pre>
<p>现在，可以使用 <code>npm run build</code> 命令，来替代我们之前使用的 <code>npx</code> 命令。注意，使用 <code>npm scripts</code>，我们可以像使用 npx 那样通过模块名引用本地安装的 npm packages。这是大多数基于 <code>npm</code> 的项目遵循的标准，因为它允许所有贡献者使用同一组通用脚本（如果必要，每个 flag 都带有 --config 标志）。</p>
<p>现在运行以下命令，然后看看你的脚本别名是否正常运行：</p>
<pre><code>npm run bundle
</code></pre>
<h2 id="浅析webpack打包输出内容">浅析webpack打包输出内容</h2>
<pre><code>npm run bundle

&gt; webpack4@1.0.0 bundle E:\project\webpack4
&gt; webpack

Hash: 768c04b37ed214487576
Version: webpack 4.42.0
Time: 98ms
Built at: 2020-03-24 4:57:54 PM
    Asset      Size  Chunks             Chunk Names
bundle.js  1.29 KiB       0  [emitted]  main
Entrypoint main = bundle.js
[0] ./src/index.js + 3 modules 741 bytes {0} [built]
    | ./src/index.js 147 bytes [built]
    | ./src/header.js 202 bytes [built]
    | ./src/content.js 198 bytes [built]
    | ./src/footer.js 194 bytes [built]


WARNING in configuration
The 'mode' option has not been set, webpack will fallback to 'production' for this value. Set 'mode' option to 'development' or 'production' to enable defaults for each environment.
You can also set it to 'none' to disable any default behavior. Learn more: https://webpack.js.org/configuration/mode/
</code></pre>
<p>从<code>webpack</code>打包输出的结果我们可以看出有个警告，那是因为我们没有指定打包输出的环境（<code>'development'</code> or<code>'production'</code>），我们可以在<code>webpack.config.js</code>新增以下代码:</p>
<pre><code>module.exports = {
  mode: 'development', //默认为production
  ...
}
</code></pre>
<p>重新执行<code>npm run bundle</code> 发现不会提出警告了，并且生成的<code>bundle.js</code>的代码没有被压缩</p>
<h2 id="什么是-loader">什么是 loader</h2>
<p>webpack 可以使用 <code>loader</code> 来预处理文件。这允许你打包除 JavaScript 之外的任何静态资源。如果你在默认配置下打包除js文件外出错，所以我们要借助<code>loader</code>来打包js外的文件</p>
<p>现在我们在<code>src</code>文件下存放一张<code>logo.jpg</code>的图片，然后在index.js引入后使用<code>webpack</code>打开</p>
<pre><code>//index.js
const logo = require('./logo.jpg')
</code></pre>
<p>执行<code>npm run bundle</code>打包后会抛出如下错误：</p>
<pre><code>ERROR in ./src/logo.jpg 1:0
Module parse failed: Unexpected character '�' (1:0)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
(Source code omitted for this binary file)
 @ ./src/index.js 5:13-34
</code></pre>
<p>这是因为webpack像我们上面说的一样，只能打包js文件，如果想打包除js以外的静态资源，此时我们就需要借用<a href="https://webpack.docschina.org/loaders/">loader</a>来帮助我们打包图片资源。想打包图片我们首先得先安装相关的<code>loader</code></p>
<h3 id="file-loader">file-loader</h3>
<pre><code>npm install file-loader -D
</code></pre>
<p>然后我们需要在<code>webpack.config.js</code>文件下配置相关的<code>module</code>规则：</p>
<pre><code>//webpack.config.js
...
module: {
    rules: [
      {
        test: /\.jpg$/,
        use: [
          {
            loader: 'file-loader' //使用相对应的loader
          }
        ]
      }
    ]
  }
</code></pre>
<p>控制台<code>npm run bundle</code>再次运行时，发现打包成功没有报错，并且在dist出口目录生成了相应的图片资源。那我们导入的图片资源变量会是什么呢，我们试着打印一下：</p>
<pre><code>const logo = require('./logo.jpg')
console.log('logo',logo)
</code></pre>
<p><img src="https://user-gold-cdn.xitu.io/2020/3/25/17110d4ca935ba3d?w=566&amp;h=153&amp;f=png&amp;s=15502" alt="" loading="lazy"><br>
可以在浏览器中看出，我们获取到的是打包生成的文件相关信息，包括图片名字。经过这个例子，我们就明白了在<code>vue</code>的脚手架项目中可以这样引入.vue相关文件的了</p>
<pre><code>import Header from 'Header.vue'
</code></pre>
<pre><code>//webpack.config.js
rules: [
    ...
      {
        test: /\.vue$/,
        use: { //只使用一个loader可以直接用对象配置
          loader: 'vue-loader'
        }
      }
    ]
</code></pre>
<p>上面案例中,我们可以看到<code>options</code>字段,这是我们可以打包文件资源的时候定义相对应的规则,比如:</p>
<pre><code>rules: [
      {
        test: /\.jpg$/,
        use: [
          {
            loader: 'file-loader', //使用相对应的loader
            options: {
              name:'[name].[ext]', //定义打包生成的文件名字
              outputPath: 'images' //定义输出的文件目录：dist/images 下
            },
          }
        ]
      }
    ]
</code></pre>
<p>这样我们就可以自定义打包文件的名字和目录，更多的规则可以查看<a href="https://webpack.js.org/loaders/file-loader/#options">官方文档配置</a></p>
<h3 id="url-loader">url-loader</h3>
<p>我们可以用<code>url-loader</code>取代<code>file-loader</code>来实现静态文件资源打包,那为什么我们有file-loader还要用url-loader,让我看看下面的例子就知道了:</p>
<p>首先我们先<code>npm install url-loader --save-dev</code>安装<code>file-loader</code>,然后在<code>webpack.config.js</code>进行相对应的配置</p>
<pre><code>rules: [
      {
        test: /\.jpg$/,
        use: [
          {
            loader: 'url-loader', //使用相对应的loader
            options: {
              limit: 10240 //单位：字节 超过10kb 的文件生成图片,否则生成base64编码
            }
          }
        ]
      }
    ]
</code></pre>
<p>运行打包后我们可以发现,超过10kb 的文件生成图片,否则生成<code>base64编码</code>。这样做的好处是什么呢，图片生成base64编码可以大大减少我们https请求，但不是所有的图片都生成base64编码，比如图片几M的生成的话，相对应js文件大小也会增加，网页打空白的时间也相对应增加，至于哪些需要转，limit需要设置多大限制根据自己的项目来，我的项目中一般是icon图标类的会转base64编码,其他大的相对应打包生成文件。</p>

        </div>

        


        <div class="flex justify-between py-8">
          

          
            <div class="next-post">
              <a href="https://250786898.github.io/post/xiao-cheng-xu-xing-neng-you-hua-xiang-mu-gui-hua-tu/">
                <h3 class="post-title">
                  小程序性能优化，项目规划图
                  <i class="ri-arrow-right-line"></i>
                </h3>
              </a>
            </div>
          
        </div>

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '',
    clientSecret: '',
    repo: '',
    owner: '',
    admin: [''],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

      </div>
    </div>

    <script src="https://250786898.github.io/media/prism.js"></script>  
<script>

Prism.highlightAll()
let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

// This should probably be throttled.
// Especially because it triggers during smooth scrolling.
// https://lodash.com/docs/4.17.10#throttle
// You could do like...
// window.addEventListener("scroll", () => {
//    _.throttle(doThatStuff, 100);
// });
// Only not doing it here to keep this Pen dependency-free.

window.addEventListener("scroll", event => {
  let fromTop = window.scrollY;

  mainNavLinks.forEach((link, index) => {
    let section = document.getElementById(decodeURI(link.hash).substring(1));
    let nextSection = null
    if (mainNavLinks[index + 1]) {
      nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
    }
    if (section.offsetTop <= fromTop) {
      if (nextSection) {
        if (nextSection.offsetTop > fromTop) {
          link.classList.add("current");
        } else {
          link.classList.remove("current");    
        }
      } else {
        link.classList.add("current");
      }
    } else {
      link.classList.remove("current");
    }
  });
});


document.addEventListener("DOMContentLoaded", function() {
  var lazyImages = [].slice.call(document.querySelectorAll(".post-feature-image.lazy"));

  if ("IntersectionObserver" in window) {
    let lazyImageObserver = new IntersectionObserver(function(entries, observer) {
      entries.forEach(function(entry) {
        if (entry.isIntersecting) {
          let lazyImage = entry.target
          lazyImage.style.backgroundImage = `url(${lazyImage.dataset.bg})`
          lazyImage.classList.remove("lazy")
          lazyImageObserver.unobserve(lazyImage)
        }
      });
    });

    lazyImages.forEach(function(lazyImage) {
      lazyImageObserver.observe(lazyImage)
    })
  } else {
    // Possibly fall back to a more compatible method here
  }
});

const menuContainer = document.querySelector('.menu-container')
const menus = document.querySelectorAll('.menu-container .menu')
const mask = document.querySelector('.mask')
const contentWrapper = document.querySelector('.content-wrapper')
const latestArticle = document.querySelector('.latest-article')
const readMore = document.querySelector('.read-more')
const indexPage = document.querySelector('.index-page')

const isHome = location.pathname === '/'
if (latestArticle) {
  latestArticle.style.display = isHome ? 'block' : 'none'
  readMore.style.display = isHome ? 'block' : 'none'
  indexPage.style.display = isHome ? 'none' : 'block'
}

const openMenu = () => {
  menuContainer.classList.add('open')
  menus.forEach(menu => {
    menu.classList.add('animated', 'fadeInLeft')
  })
  mask.classList.add('open')
  contentWrapper.classList.add('is-second')
}

const closeMenu = () => {
  menuContainer.classList.remove('open')
  menus.forEach(menu => {
    menu.classList.remove('animated', 'fadeInLeft')
  })
  mask.classList.remove('open')
  contentWrapper.classList.remove('is-second')
}
</script>
  
  </body>
</html>
